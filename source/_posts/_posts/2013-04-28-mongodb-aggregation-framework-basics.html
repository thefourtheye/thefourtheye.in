---
layout: post
title: "MongoDB Aggregation Framework Basics Explained"
date: 2013-04-28T16:45:00+05:30
---

<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on">This post assumes that, the reader has a very good understanding of SQL.<br /><br />To understand the MongoDB's aggregation framework, lets start with inserting the following data.<br /><pre class="prettyprint">db.Student.insert ({Student_Name:"Kalki",  Class: "2", Mark_Scored:100, Subject: ["Tamil", "English", "Maths"]})<br />db.Student.insert ({Student_Name:"Matsya", Class: "1", Mark_Scored:10,  Subject: ["Tamil", "English"]})<br /><br />db.Student.insert ({Student_Name:"Krishna",Class: "1", Mark_Scored:50,  Subject: ["Tamil"]})<br />db.Student.insert ({Student_Name:"Buddha", Class: "2", Mark_Scored:60,  Subject: ["Tamil"]})<br />db.Student.insert ({Student_Name:"Rama",   Class: "2", Mark_Scored:80,  Subject: ["Tamil"]})<br /><br />db.Student.insert ({Student_Name:"Krishna",Class: "1", Mark_Scored:50,  Subject: ["English"]})<br />db.Student.insert ({Student_Name:"Buddha", Class: "2", Mark_Scored:60,  Subject: ["English"]})<br />db.Student.insert ({Student_Name:"Rama",   Class: "2", Mark_Scored:80,  Subject: ["English"]})<br /><br />db.Student.insert ({Student_Name:"Matsya", Class: "1", Mark_Scored:67,  Subject: ["Maths"]})<br />db.Student.insert ({Student_Name:"Krishna",Class: "1", Mark_Scored:95,  Subject: ["Maths"]})<br />db.Student.insert ({Student_Name:"Buddha", Class: "2", Mark_Scored:88,  Subject: ["Maths"]})<br />db.Student.insert ({Student_Name:"Rama",   Class: "2", Mark_Scored:40,  Subject: ["Maths"]})<br /></pre><br /><h1>Pipeline</h1><p>The aggregation framework is based on pipeline concept, just like <a href="http://en.wikipedia.org/wiki/Pipeline_%28Unix%29">unix pipeline</a>. There can be N number of operators. Output of first operator will be fed as input to the second operator. Output of second operator will be fed as input to the third operator and so on.</p><br /><h1>Pipeline Operators</h1><p>Following are the basic pipeline operators and let us make use of these operators over the sample data which we created. <b>We are not going to discuss about Map-Reduce in this post.</b><br /><ol><li><a href="#match">$match</a></li><li><a href="#unwind">$unwind</a></li><li><a href="#group">$group</a></li><li><a href="#project">$project</a></li><li><a href="#skipandlimit">$skip</a></li><li><a href="#skipandlimit">$limit</a></li><li><a href="#sort">$sort</a></li></ol></p><h2 id="match">$match</h2><p>This is similar to MongoDB Collection's find method and SQL's WHERE clause. Basically this filters the data which is passed on to the next operator. There can be multiple $match operators in the pipeline.</p><br /><b>Note:</b>The data what we pass to the aggregate function should be a list of Javascript objects (Python dictionaries). Each and every operator should be in a separate javascript object like shown in all the examples below.<br /><br /><b>Example:</b>We want to consider only the marks of the students who study in Class "2"<br /><pre class="prettyprint">db.Student.aggregate ([<br />  {<br />     "$match":<br />     {<br />        "Class":"2"<br />     }<br />  }<br />  ])<br /></pre>and the result is<br /><pre class="prettyprint">{<br />	"result" : [<br />		{<br />			"_id" : ObjectId("517cbb98eccb9ee3d000fa5c"),<br />			"Student_Name" : "Kalki",<br />			"Class" : "2",<br />			"Mark_Scored" : 100,<br />			"Subject" : [<br />				"Tamil",<br />				"English",<br />				"Maths"<br />			]<br />		},<br />		{<br />			"_id" : ObjectId("517cbb98eccb9ee3d000fa5f"),<br />			"Student_Name" : "Buddha",<br />			"Class" : "2",<br />			"Mark_Scored" : 60,<br />			"Subject" : [<br />				"Tamil"<br />			]<br />		},<br />		{<br />			"_id" : ObjectId("517cbb98eccb9ee3d000fa60"),<br />			"Student_Name" : "Rama",<br />			"Class" : "2",<br />			"Mark_Scored" : 80,<br />			"Subject" : [<br />				"Tamil"<br />			]<br />		},<br />		{<br />			"_id" : ObjectId("517cbb98eccb9ee3d000fa62"),<br />			"Student_Name" : "Buddha",<br />			"Class" : "2",<br />			"Mark_Scored" : 60,<br />			"Subject" : [<br />				"English"<br />			]<br />		},<br />		{<br />			"_id" : ObjectId("517cbb98eccb9ee3d000fa63"),<br />			"Student_Name" : "Rama",<br />			"Class" : "2",<br />			"Mark_Scored" : 80,<br />			"Subject" : [<br />				"English"<br />			]<br />		},<br />		{<br />			"_id" : ObjectId("517cbb98eccb9ee3d000fa66"),<br />			"Student_Name" : "Buddha",<br />			"Class" : "2",<br />			"Mark_Scored" : 88,<br />			"Subject" : [<br />				"Maths"<br />			]<br />		},<br />		{<br />			"_id" : ObjectId("517cbb98eccb9ee3d000fa67"),<br />			"Student_Name" : "Rama",<br />			"Class" : "2",<br />			"Mark_Scored" : 40,<br />			"Subject" : [<br />				"Maths"<br />			]<br />		}<br />	],<br />	"ok" : 1<br />}<br /></pre>Let us say, we want to consider only the marks of the students who study in Class "2" and whose marks are more than or equal to 80<br /><pre class="prettyprint">db.Student.aggregate ([<br />  {<br />     "$match":<br />     {<br />        "Class":"2",<br />        "Mark_Scored":<br />        {<br />           "$gte": 80<br />        }<br />     }<br />  }<br />  ])<br /></pre>Or we can use $match operator twice to achieve the same result<br /><pre class="prettyprint">db.Student.aggregate ([<br />  {<br />     "$match":<br />     {<br />        "Class":"2",<br />     }<br />  },<br />  {<br />     "$match":<br />     {<br />        "Mark_Scored":<br />        {<br />           "$gte": 80<br />        }<br />     }<br />  }<br />  ])<br /></pre>and the result would be<br /><pre class="prettyprint">{<br />	"result" : [<br />		{<br />			"_id" : ObjectId("517cbb98eccb9ee3d000fa5c"),<br />			"Student_Name" : "Kalki",<br />			"Class" : "2",<br />			"Mark_Scored" : 100,<br />			"Subject" : [<br />				"Tamil",<br />				"English",<br />				"Maths"<br />			]<br />		},<br />		{<br />			"_id" : ObjectId("517cbb98eccb9ee3d000fa60"),<br />			"Student_Name" : "Rama",<br />			"Class" : "2",<br />			"Mark_Scored" : 80,<br />			"Subject" : [<br />				"Tamil"<br />			]<br />		},<br />		{<br />			"_id" : ObjectId("517cbb98eccb9ee3d000fa63"),<br />			"Student_Name" : "Rama",<br />			"Class" : "2",<br />			"Mark_Scored" : 80,<br />			"Subject" : [<br />				"English"<br />			]<br />		},<br />		{<br />			"_id" : ObjectId("517cbb98eccb9ee3d000fa66"),<br />			"Student_Name" : "Buddha",<br />			"Class" : "2",<br />			"Mark_Scored" : 88,<br />			"Subject" : [<br />				"Maths"<br />			]<br />		}<br />	],<br />	"ok" : 1<br />}<br /></pre><h2 id="unwind">$unwind</h2><p>This will be very useful when the data is stored as list. When the unwind operator is applied on a list data field, it will generate a new record for each and every element of the list data field on which unwind is applied. It basically flattens the data. Lets see an example to understand this better</p><b>Note:</b> The field name, on which unwind is applied, should be prefixed with $ (dollar sign)<br /><br /><b>Example:</b>Lets apply unwind over "Kalki"'s data.<br /><pre class="prettyprint">db.Student.aggregate ([<br />   {<br />      "$match":<br />      {<br />         "Student_Name": "Kalki",<br />      }<br />   }<br />])<br /></pre>This generates the following output<br /><pre class="prettyprint">{<br />	"result" : [<br />		{<br />			"_id" : ObjectId("517cbb98eccb9ee3d000fa5c"),<br />			"Student_Name" : "Kalki",<br />			"Class" : "2",<br />			"Mark_Scored" : 100,<br />			"Subject" : [<br />				"Tamil",<br />				"English",<br />				"Maths"<br />			]<br />		}<br />	],<br />	"ok" : 1<br />}<br /></pre>Whereas<br /><pre class="prettyprint">db.Student.aggregate ([<br />   {<br />      "$match":<br />      {<br />         "Student_Name": "Kalki",<br />      }<br />   },<br />   {<br />      "$unwind": "$Subject"<br />   }<br />])<br /></pre>will generate the following output<br /><pre class="prettyprint">{<br />	"result" : [<br />		{<br />			"_id" : ObjectId("517cbb98eccb9ee3d000fa5c"),<br />			"Student_Name" : "Kalki",<br />			"Class" : "2",<br />			"Mark_Scored" : 100,<br />			"Subject" : "Tamil"<br />		},<br />		{<br />			"_id" : ObjectId("517cbb98eccb9ee3d000fa5c"),<br />			"Student_Name" : "Kalki",<br />			"Class" : "2",<br />			"Mark_Scored" : 100,<br />			"Subject" : "English"<br />		},<br />		{<br />			"_id" : ObjectId("517cbb98eccb9ee3d000fa5c"),<br />			"Student_Name" : "Kalki",<br />			"Class" : "2",<br />			"Mark_Scored" : 100,<br />			"Subject" : "Maths"<br />		}<br />	],<br />	"ok" : 1<br />}<br /></pre><h2 id="group">$group</h2><p>Now that we have flatten the data to be processed, lets try and group the data to process them. The group pipeline operator is similar to the SQL's GROUP BY clause. In SQL, we can't use GROUP BY unless we use any of the aggregation functions. The same way, we have to use an aggregation function in MongoDB as well. You can read more about the aggregation functions <a href="http://docs.mongodb.org/manual/reference/aggregation/#expressions">here</a>. As most of them are like in SQL, I don't think much explanation would be needed.</p><br /><b>Note:</b> The _id element in group operator is a must. We cannot change it to some other name. MongoDB identifies the grouping expression with the _id field only.<br /><br /><b>Example:</b> Lets try and get the sum of all the marks scored by each and every student, in Class "2"<br /><pre class="prettyprint">db.Student.aggregate ([<br />   {<br />      "$match":<br />      {<br />         "Class": "2"<br />      }<br />   },<br />   {<br />      "$unwind": "$Subject"<br />   },<br />   {<br />      "$group":<br />      {<br />         "_id":<br />         {<br />            "Student_Name" : "$Student_Name"<br />         },<br />         "Total_Marks":<br />         {<br />            "$sum": "$Mark_Scored"<br />         }<br />      }<br />   }<br />])<br /></pre>If we look at this aggregation example, we have specified an _id element and Total_Marks element. The _id element tells MongoDB to group the documents based on Student_Name field. The Total_Marks uses an aggregation function <a href="http://docs.mongodb.org/manual/reference/aggregation/sum/#grp._S_sum">$sum</a>, which basically adds up all the marks and returns the sum. This will produce this Output<br /><pre class="prettyprint">{<br />	"result" : [<br />		{<br />			"_id" : {<br />				"Student_Name" : "Rama"<br />			},<br />			"Total_Marks" : 200<br />		},<br />		{<br />			"_id" : {<br />				"Student_Name" : "Buddha"<br />			},<br />			"Total_Marks" : 208<br />		},<br />		{<br />			"_id" : {<br />				"Student_Name" : "Kalki"<br />			},<br />			"Total_Marks" : 300<br />		}<br />	],<br />	"ok" : 1<br />}<br /></pre>We can use the sum function to count the number of records match the grouped data. Instead of "$sum": "$Mark_Scored", "$sum": 1 will count the number of records. "$sum": 2 will add 2 for each and every grouped data.<br /><pre class="prettyprint">db.Student.aggregate ([<br />   {<br />      "$match":<br />      {<br />         "Class": "2"<br />      }<br />   },<br />   {<br />      "$unwind": "$Subject"<br />   },<br />   {<br />      "$group":<br />      {<br />         "_id":<br />         {<br />            "Student_Name" : "$Student_Name"<br />         },<br />         "Total_Marks":<br />         {<br />            "$sum": 1<br />         }<br />      }<br />   }<br />])<br /></pre>This will produce this Output<br /><pre class="prettyprint">{<br />	"result" : [<br />		{<br />			"_id" : {<br />				"Student_Name" : "Rama"<br />			},<br />			"Total_Marks" : 3<br />		},<br />		{<br />			"_id" : {<br />				"Student_Name" : "Buddha"<br />			},<br />			"Total_Marks" : 3<br />		},<br />		{<br />			"_id" : {<br />				"Student_Name" : "Kalki"<br />			},<br />			"Total_Marks" : 3<br />		}<br />	],<br />	"ok" : 1<br />}<br /></pre>This is because each and every student has marks for three subjects.<br /><h2 id="project">$project</h2><p>The project operator is similar to SELECT in SQL. We can use this to rename the field names and select/deselect the fields to be returned, out of the grouped fields. If we specify 0 for a field, it will NOT be sent in the pipeline to the next operator. We can even flatten the data using project as shown in the example below</p><b>Example:</b><br /><pre class="prettyprint">db.Student.aggregate ([<br />   {<br />      "$match":<br />      {<br />         "Class": "2"<br />      }<br />   },<br />   {<br />      "$unwind": "$Subject"<br />   },<br />   {<br />      "$group":<br />      {<br />         "_id":<br />         {<br />            "Student_Name" : "$Student_Name"<br />         },<br />         "Total_Marks":<br />         {<br />            "$sum": "$Mark_Scored"<br />         }<br />      }<br />   },<br />   {<br />      "$project":<br />      {<br />         "_id":0,<br />         "Name":  "$_id.Student_Name",<br />         "Total": "$Total_Marks"<br />      }<br />   }<br />])<br /></pre>will result in<br /><pre class="prettyprint">{<br />	"result" : [<br />		{<br />			"Name" : "Rama",<br />			"Total" : 200<br />		},<br />		{<br />			"Name" : "Buddha",<br />			"Total" : 208<br />		},<br />		{<br />			"Name" : "Kalki",<br />			"Total" : 300<br />		}<br />	],<br />	"ok" : 1<br />}<br /></pre>Lets say we try to retrieve Subject field by specifying project like shown below. MongoDB will simply ignore the Subject field, since it is not used in the group operator's _id field.<br /><pre class="prettyprint">"$project":<br />{<br />   "_id":0,<br />   "Subject":1,<br />   "Name":  "$_id.Student_Name",<br />   "Total": "$Total_Marks"<br />}<br /></pre><h2 id="sort">$sort</h2>This is similar to SQL's ORDER BY clause. To sort a particular field in descending order specify -1 and specify 1 if that field has to be sorted in ascending order. I don't think this section needs more explanation. Lets straight away look at an example<br /><b>Example:</b><br /><pre class="prettyprint">db.Student.aggregate ([<br />   {<br />      "$match":<br />      {<br />         "Class": "2"<br />      }<br />   },<br />   {<br />      "$unwind": "$Subject"<br />   },<br />   {<br />      "$group":<br />      {<br />         "_id":<br />         {<br />            "Student_Name" : "$Student_Name"<br />         },<br />         "Total_Marks":<br />         {<br />            "$sum": "$Mark_Scored"<br />         }<br />      }<br />   },<br />   {<br />      "$project":<br />      {<br />         "_id":0,<br />         "Name":  "$_id.Student_Name",<br />         "Total": "$Total_Marks"<br />      }<br />   },<br />   {<br />      "$sort":<br />      {<br />         "Total":-1,<br />         "Name":1<br />      }<br />   }<br />])<br /></pre>Will Sort the data based on Marks in descending Order first and then by Name in Ascending Order.<br /><pre class="prettyprint">{<br />	"result" : [<br />		{<br />			"Name" : "Kalki",<br />			"Total" : 300<br />		},<br />		{<br />			"Name" : "Buddha",<br />			"Total" : 208<br />		},<br />		{<br />			"Name" : "Rama",<br />			"Total" : 200<br />		}<br />	],<br />	"ok" : 1<br />}<br /></pre><h2 id="skipandlimit">$limit and $skip</h2><p>These two operators can be used to limit the number of documents being returned. They will be more useful when we need pagination support.</p><b>Example:</b><br /><pre class="prettyprint">db.Student.aggregate ([<br />   {<br />      "$match":<br />      {<br />         "Class": "2"<br />      }<br />   },<br />   {<br />      "$unwind": "$Subject"<br />   },<br />   {<br />      "$group":<br />      {<br />         "_id":<br />         {<br />            "Student_Name" : "$Student_Name"<br />         },<br />         "Total_Marks":<br />         {<br />            "$sum": "$Mark_Scored"<br />         }<br />      }<br />   },<br />   {<br />      "$project":<br />      {<br />         "_id":0,<br />         "Name":  "$_id.Student_Name",<br />         "Total": "$Total_Marks"<br />      }<br />   },<br />   {<br />      "$sort":<br />      {<br />         "Total":-1,<br />         "Name":1<br />      }<br />   },<br />   {<br />      "$limit":2,<br />   },<br />   {<br />      "$skip":1,<br />   }<br />])<br /></pre>will result in<br /><pre class="prettyprint">{ "result" : [ { "Name" : "Buddha", "Total" : 208 } ], "ok" : 1 }<br /></pre>Because the limit operator receives 3 documents from the sort operator and allows only the first two documents to pass through it, thereby dropping Rama's record. The skip operator skips one document (that means the first document (Kalki's document) is dropped) and allows only the Buddha's document to pass through.<br /><br />All the examples shown here are readily usable with pyMongo (Just replace db.Student with your Collection object name)<br /><br /><br /></div></div>
