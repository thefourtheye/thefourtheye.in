---
layout: post
title: "Timus - 1018 - Binary Apple Tree - Dynamic Programming"
date: 2013-04-21T23:00:00+05:30
categories:
 - Dynamic Programming
 - Sport Programming
 - Timus
---

<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on">Today, I saw this interesting problem. <br /><br /><a href="http://acm.timus.ru/problem.aspx?space=1&num=1018">Timus - 1018 - Binary Apple Tree</a><br /><br />When I started working on this, I didnt know why do we need Dynamic Programming to solve this. My idea was pretty simple.  <blockquote>1. While reading Inputs find the total number of apples<br />2. Find all the leaf Branches (I mean branches without any branches on them)<br />3. Get the branch with the least number of apples and remove that<br />4. Goto Step 2 until N - Q - 1 times. (N is the total number of enumerated points on the tree, Q is the number of branches to keep, Always there will be N - 1 branches on the binary tree. So N - Q - 1 will give the number of branches to be removed) </blockquote>It was pretty straight forward to implement.<br /><pre class="prettyprint"># include &lt;cstdio&gt;<br /># include &lt;map&gt;<br /># include &lt;set&gt;<br /># include &lt;bitset&gt;<br />using namespace std;<br />int N, Q;<br />unsigned long long Total = 0;<br />struct Branch<br />{<br /> bool operator&lt; (const Branch & branch) const<br /> {<br />  if (this-&gt;Apples == branch.Apples)<br />  {<br />   if (this-&gt;Start == branch.Start)<br />    return this-&gt;End &lt; branch.End;<br />   return this-&gt;Start&lt; branch.Start;<br />  }<br />  return this-&gt;Apples &lt; branch.Apples;<br /> }<br /> Branch (int a, int b, int c){Start = a; End = b; Apples = c;}<br /> int Start, End, Apples;<br />};<br />set &lt;Branch&gt; Edges;<br />bitset &lt;101&gt; Visited;<br />map &lt;int, map &lt;int, int&gt; &gt; Tree;<br />void FindEdges (int current, int parent)<br />{<br /> //printf ("%d\t%d\n", current, parent);<br /> if (Visited[current]) return;<br /> //printf ("%d\t%d Not Visited\n", current, parent);<br /> Visited[current] = true;<br /> map&lt;int, int&gt;::iterator it = Tree[current].begin();<br /> if (Tree[current].size() == 1)<br />  Edges.insert (Branch (parent, current, Tree[parent][current]));<br /> else<br />  for (; it != Tree[current].end(); it++)<br />   if (!Visited[it-&gt;first])<br />    FindEdges (it-&gt;first, current);<br />}<br />int main()<br />{<br /> //freopen ("Input.txt", "r", stdin);<br /> //freopen ("Scratch.txt", "w", stdout);<br /> scanf ("%d%d", &N, &Q);<br /> Q = N - 1 - Q;<br /> int A, B, C;<br /> for (int i = 0; i &lt; N - 1; i++)<br /> {<br />  scanf ("%d%d%d", &A, &B, &C);<br />  Tree[A][B] = C;<br />  Tree[B][A] = C;<br />  Total += C;<br /> }<br /> for (int i = 0; i &lt; Q; i++)<br /> {<br />  Edges.clear();<br />  Visited.reset();<br />  map&lt;int, int&gt;::iterator it1 = Tree[1].begin();<br />  Visited[1] = true;<br />  for (; it1 != Tree[1].end(); it1++)<br />   FindEdges(it1-&gt;first, 1);<br />  //printf ("Edges Size : %lu\n", Edges.size());<br />  set&lt;Branch&gt;::iterator it = Edges.begin();<br />  //printf ("%d\t%d\t%d\n", it-&gt;Start, it-&gt;End, it-&gt;Apples);<br />  Total -= it-&gt;Apples;<br />  Tree[it-&gt;Start].erase (it-&gt;End);<br />  Tree[it-&gt;End].erase (it-&gt;Start);<br /> }<br /> printf ("%llu\n", Total);<br />}<br /></pre>However, this solution was failing so many times. Then I found the testcase for which this program was failing.  <pre class="prettyprint">4 1<br />1 2 1<br />1 3 2<br />2 4 3<br /><br /></pre>The above shown solution returns 1 as the result whereas the optimal result is 2. This approach is greedy approach I believe. <br />In the first iteration, it detects the branches <pre class="prettyprint">1 3 2<br />2 4 3<br /></pre>and removes the branch 1 3 2, since it has the least number of apples and in the next iteration it detects the following branch <pre class="prettyprint">2 4 3<br /></pre>since that is the only leaf branch available and it removes that, leaving us with the suboptimal solution 1. <br /><br />Here is the DP solution which can really solve this problem and this got accepted by Timus.<br /><br /><pre class="prettyprint">#include &lt;cstdio&gt;<br />#include &lt;cstring&gt;<br />#include &lt;vector&gt;<br />#include &lt;algorithm&gt;<br /><br />using namespace std;<br /><br />int N,Q, Tree[101][101], DP[101][101];<br />int solve (int current, int parent, int q)<br />{<br /> if (q &lt;= 0) return 0;<br /> int lindex = -1, rindex = -1;<br /> int & result = DP[current][q];<br /> if (result != -1) return result;<br /> for (int i = 0; i &lt; 101; i++)<br />  if (Tree[current][i] != -1 && i != parent) {lindex = i; break;}<br /> for (int i = (lindex == -1?0:lindex+1); i &lt; 101; i++)<br />  if (Tree[current][i] != -1 && i != parent) {rindex = i; break;}<br /> //printf ("%d\t%d\t%d\t%d\t%d\n", current, parent, lindex, rindex, q);<br /> if (lindex == -1 || rindex == -1) return 0;<br /> for (int i = 0; i &lt;= q; i++)<br />  result = max (result, (i == q?0:Tree[current][lindex] + solve(lindex, current, q - i - 1))<br />   + (i == 0?0:Tree[current][rindex] + solve(rindex, current, i - 1)));<br /> //printf ("Returning %d\n", result);<br /> return result;<br />}<br />int main()<br />{<br /> //freopen ("Input.txt", "r", stdin);<br /> //freopen ("Scratch.txt", "w", stdout);<br /> scanf("%d%d",&N,&Q);<br /> memset (Tree, -1, sizeof Tree);<br /> memset (DP, -1, sizeof DP);<br /> for (int i = 0; i &lt; N; i++)<br />  for (int j = 0, x, y, z; j &lt; N; j++)<br />  {<br />   scanf ("%d%d%d", &x, &y, &z);<br />   Tree [x][y] = z;<br />   Tree [y][x] = z;<br />  }<br /> printf ("%d\n", solve (1, 0, Q));<br /> return 0;<br />}<br /></pre>Please write to me if you want me to explain this program. We can do that over chat. </div></div>
